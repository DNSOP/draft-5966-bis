<?xml version='1.0' encoding='UTF-8' ?> 
<!-- was: <?xml version="1.0" encoding="US-ASCII"?> -->
<!-- This template is for creating an Internet Draft using xml2rfc,
which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
There has to be one entity for each item to be referenced. 
An alternate method (rfc include) is described in the references. -->
<!ENTITY RFC5966 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5966.xml">
<!ENTITY I-D.draft-ietf-dnsop-edns-tcp-keepalive SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-dnsop-edns-tcp-keepalive-00.xml">
<!ENTITY RFC2119 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2629 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2629.xml">
<!ENTITY RFC3552 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3552.xml">
<!ENTITY RFC5625 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5625.xml">
<!ENTITY RFC6824 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6824.xml">
<!ENTITY RFC0768 PUBLIC '' 'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.0768.xml'>
<!ENTITY RFC0793 PUBLIC '' 'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.0793.xml'>
<!ENTITY RFC1034 PUBLIC '' 'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1034.xml'>
<!ENTITY RFC1035 PUBLIC '' 'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1035.xml'>
<!ENTITY RFC1123 PUBLIC '' 'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1123.xml'>
<!ENTITY RFC2119 PUBLIC '' 'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml'>
<!ENTITY RFC2616 PUBLIC '' 'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2616.xml'>
<!ENTITY RFC6891 PUBLIC '' 'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6891.xml'>
<!ENTITY RFC4033 PUBLIC '' 'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4033.xml'>
<!ENTITY RFC5155 PUBLIC '' 'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5155.xml'>
<!ENTITY RFC5358 PUBLIC '' 'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5358.xml'>
<!ENTITY RFC5625 PUBLIC '' 'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5625.xml'>
<!ENTITY RFC7323 PUBLIC '' 'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7323.xml'>
<!ENTITY RFC7230 PUBLIC '' 'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7230.xml'>
<!ENTITY RFC2920 PUBLIC '' 'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2920.xml'>
<!ENTITY RFC4786 PUBLIC '' 'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4786.xml'>
<!ENTITY RFC7413 PUBLIC '' 'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7413.xml'>
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
(Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
(using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="std" docName="draft-ietf-dnsop-5966bis-00" ipr="trust200902" obsoletes="5966">
  <!-- category values: std, bcp, info, exp, and historic
  ipr values: full3667, noModification3667, noDerivatives3667
  you can add the attributes updates="NNNN" and obsoletes="NNNN" 
  they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the 
    full title is longer than 39 characters -->

    <title abbrev="DNS over TCP">DNS Transport over TCP - Implementation Requirements</title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <!-- Another author who claims to be an editor -->

    <author fullname="John Dickinson" initials="J.A." surname="Dickinson">
      <organization>Sinodun Internet Technologies</organization>
      <address>
        <postal>
          <street>Magdalen Centre</street>
          <street>Oxford Science Park</street>
          <city>Oxford</city>
          <region></region>
          <code>OX4 4GA</code>
          <country>UK</country>
        </postal>
        <email>jad@sinodun.com</email>
        <uri>http://sinodun.com</uri>
      </address>
    </author>
    <author fullname="Ray Bellis" initials="R.P." surname="Bellis">
      <organization>Nominet</organization>
      <address>
        <postal>
          <street>Edmund Halley Road</street>
          <city>Oxford</city>
          <region></region>
          <code>OX4 4DQ</code>
          <country>UK</country>
        </postal>
        <phone>+44 1865 332211</phone>
        <email>ray.bellis@nominet.org.uk</email>
        <uri>http://www.nominet.org.uk/</uri>
      </address>
    </author>
    <author fullname="Allison Mankin" initials="A." surname="Mankin">
      <organization>Verisign Labs</organization>
      <address>
        <postal>
          <street>12061 Bluemont Way</street>
          <city>Reston</city>
          <region>VA</region>
          <code>20190</code>
          <country>US</country>
        </postal>
        <phone>+1 703 948-3200</phone>
        <email>amankin@verisign.com</email>
      </address>
    </author>
    <author fullname="Duane Wessels" initials="D." surname="Wessels">
      <organization>Verisign Labs</organization>
      <address>
        <postal>
          <street>12061 Bluemont Way</street>
          <city>Reston</city>
          <region>VA</region>
          <code>20190</code>
          <country>US</country>
        </postal>
        <phone>+1 703 948-3200</phone>
        <email>dwessels@verisign.com</email>
      </address>
    </author>

    <date month="December" year="2014" />

    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill 
          in the current day for you. If only the current year is specified, xml2rfc will fill 
    in the current day and month for you. If the year is not the current one, it is 
    necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the 
    purpose of calculating the expiry date).  With drafts it is normally sufficient to 
    specify just the year. -->

    <!-- Meta-data Declarations -->

    <area>ops</area>

    <workgroup>dnsop</workgroup>

    <!-- WG name at the upperleft corner of the doc,
    IETF is fine for individual submissions.  
If this element is not present, the default is "Network Working Group",
    which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>DNS</keyword>
    <keyword>TCP/IP</keyword>
    <keyword>transport</keyword>
    <!-- Keywords will be incorporated into HTML output
    files in a meta tag but they have no effect on text or nroff
    output. If you submit your draft to the RFC Editor, the
    keywords will be used for the search engine. -->

    <abstract>
      <t>
        This document specifies the requirement for support of TCP as a
        transport protocol for DNS implementations and provides
        guidelines towards DNS-over-TCP performance on par with that
        of DNS-over-UDP.
      </t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>
        Most <xref target="RFC1034">DNS</xref> transactions take place over <xref
          target="RFC0768">UDP</xref>. <xref target="RFC0793">TCP</xref> is always used
        for full zone transfers (AXFR) and is often used for messages whose sizes exceed the DNS
        protocol's original 512-byte limit.
      </t>
      <t> Section 6.1.3.2 of <xref target="RFC1123"/> states: <list>
          <t>
            <vspace/>DNS resolvers and recursive servers MUST support UDP, and SHOULD
            support TCP, for sending (non-zone-transfer) queries.
          </t>
        </list>
      </t>
      <t>
        However, some implementors have taken the text quoted above to mean that TCP support
        is an optional feature of the DNS protocol.
      </t>
      <t>
        The majority of DNS server operators already support TCP and the default
        configuration for most software implementations is to support TCP. The primary
        audience for this document is those implementors whose failure to support TCP
        restricts interoperability and limits deployment of new DNS features.
      </t>
      <t> This document therefore updates the core DNS protocol specifications such that
        support for TCP is henceforth a REQUIRED part of a full DNS protocol implementation.
      </t>
      <t>
        There are several advantages and disadvantages to the increased use of
        TCP as well as implementation
        details that need to be considered. This document addresses these
        issues and therefore extends the content of <xref target="RFC5966"/>, with
        additional considerations and lessons learned from new research and
        implementations <xref target="Connection-Oriented-DNS"/>.
      </t>
      <t>
        Whilst this document makes no specific requirements for operators of DNS
        servers to meet, it does offer some suggestions to operators to help 
        ensure that support for TCP on their servers and network is optimal.
        It should be noted that failure to support TCP (or the blocking of DNS over TCP at
        the network layer) may result in resolution failure and/or application-level
        timeouts.
      </t>
    
    </section>
    <section title="Requirements Terminology">
      <t>
        The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref
          target="RFC2119"/>.
      </t>
    </section>
    <section title="Terminology">
      <t>
        <list style="symbols">
          <t>
            Connection Reuse: the sending of multiple queries and responses over
            a single TCP connection.
          </t>
          <t>
            Pipelining: the sending of multiple queries and responses over
            a single TCP connection but not waiting for any outstanding replies
            before sending another query.
          </t>
          <t>
            Out-Of-Order Processing: The processing of queries in parallel 
            and the returning of individual responses as soon as they are 
            available, possibly out-of-order. This will most likely occur in 
            recursive servers, however it is possible in authoritative servers
            that, for example, have different backend data stores. 
          </t>
        </list>
      </t>
    </section>

    <section title="Discussion">

      <t> In the absence of EDNS0 (Extension Mechanisms for DNS 0) (see below), the normal
        behaviour of any DNS server needing to send a UDP response that would exceed the
        512-byte limit is for the server to truncate the response so that it fits within
        that limit and then set the TC flag in the response header. When the client receives
        such a response, it takes the TC flag as an indication that it should retry over TCP
        instead.</t>

      <t> RFC 1123 also says: <list>
          <t>
            <vspace/>... it is also clear that some new DNS record types defined in the
            future will contain information exceeding the 512 byte limit that applies to
            UDP, and hence will require TCP. Thus, resolvers and name servers should
            implement TCP services as a backup to UDP today, with the knowledge that
            they will require the TCP service in the future.</t>
        </list>
      </t>

      <t> Existing deployments of <xref target="RFC4033">DNS Security (DNSSEC)</xref> have
        shown that truncation at the 512-byte boundary is now commonplace. For example, a
        Non-Existent Domain (NXDOMAIN) (RCODE == 3) response from a DNSSEC-signed zone using
        <xref target="RFC5155">NextSECure 3 (NSEC3)</xref> is almost invariably larger
        than 512 bytes.</t>

      <t> Since the original core specifications for DNS were written, the Extension
        Mechanisms for DNS (<xref target="RFC6891">EDNS0</xref>) have been introduced. These
        extensions can be used to indicate that the client is prepared to receive UDP
        responses larger than 512 bytes. An EDNS0-compatible server receiving a request from
        an EDNS0-compatible client may send UDP packets up to that client's announced buffer
        size without truncation.</t>

      <t> However, transport of UDP packets that exceed the size of the path MTU causes IP
        packet fragmentation, which has been found to be unreliable in some circumstances.
        Many firewalls routinely block fragmented IP packets, and some do not implement the
        algorithms necessary to reassemble fragmented packets. Worse still, some network
        devices deliberately refuse to handle DNS packets containing EDNS0 options. Other
        issues relating to UDP transport and packet size are discussed in <xref
          target="RFC5625"/>.</t>

      <t>The MTU most commonly found in the core of the Internet is around 1500 bytes, and
        even that limit is routinely exceeded by DNSSEC-signed responses. </t>

      <t> The future that was anticipated in RFC 1123 has arrived, and the only standardised
        UDP-based mechanism that may have resolved the packet size issue has been found
        inadequate.</t>

    </section>

    <section title="Transport Protocol Selection" anchor="selection">

      <t> All general-purpose DNS implementations MUST support both UDP and TCP transport.</t>

      <t>
        <list style="symbols">

          <t> Authoritative server implementations MUST support TCP so that they do not
            limit the size of responses to what fits in a single UDP packet.</t>

          <t> Recursive server (or forwarder) implementations MUST support TCP so that
            they do not prevent large responses from a TCP-capable server from reaching
            its TCP-capable clients.</t>

          <t> Stub resolver implementations (e.g., an operating system's DNS resolution
            library) MUST support TCP since to do otherwise would limit their
            interoperability with their own clients and with upstream servers. </t>

        </list>
      </t>



      <t> Regarding the choice of when to use UDP or TCP, Section 6.1.3.2 of RFC 1123 also
        says: <list>
          <t>
            <vspace/>... a DNS resolver or server that is sending a non-zone-transfer
            query MUST send a UDP query first.</t>
        </list>
      </t>

      <t>
        This requirement is hereby relaxed. A resolver MAY elect to send 
        either TCP or UDP queries depending on local operational reasons. TCP 
        MAY be used before sending any UDP queries. If it already has an 
        open TCP connection to the server it SHOULD reuse this connection. 
        In essence, TCP SHOULD be considered as valid a transport as UDP.
      </t>
      <t>
        In addition it is noted that all Recursive and Authoritative servers 
        MUST send responses using the same transport as the query arrived on. In
        the case of TCP this MUST also be the same connection. 
      </t>

    </section>

    <section title="Connection Handling" anchor="timeouts">
      
      <t> One perceived disadvantage to DNS over TCP is the added connection
        setup latency, generally equal to one RTT.  To amortize connection
        setup costs, both clients and servers SHOULD support connection
        reuse by sending multiple queries and responses over a single
        TCP connection.</t>

      <t> DNS currently has no connection signaling mechanism.  Clients
        and servers may close a connection at any time.  Clients MUST
        be prepared to retry failed queries on broken connections.</t>
      
      <t> Section 4.2.2 of <xref target="RFC1035"/> says:<list>
          <t>
            <vspace/>If the server needs to close a dormant connection to reclaim
            resources, it should wait until the connection has been idle for a period on
            the order of two minutes. In particular, the server should allow the SOA and
            AXFR request sequence (which begins a refresh operation) to be made on a
            single connection. Since the server would be unable to answer queries
            anyway, a unilateral close or reset may be used instead of a graceful close.
          </t>
        </list>
      </t>

      <t> Other more modern protocols (e.g., <xref target="RFC7230">HTTP/1.1</xref>) have support
        for persistent TCP connections and operational experience has shown that long
        timeouts can easily cause resource exhaustion and poor response under heavy load.
        Intentionally opening many connections and leaving them dormant can trivially create
        a "denial-of-service" attack.</t>

      <t> It is therefore RECOMMENDED that the default application-level idle period should be
        of the order of seconds, but no particular value is specified. In practice, the idle
        period may vary dynamically, and servers MAY allow dormant connections to remain
        open for longer periods as resources permit.</t>

      <t> To mitigate the risk of unintentional server overload, DNS clients MUST take care to
        minimize the number of concurrent TCP connections made to any individual server.
        Similarly, servers MAY impose limits on the number of concurrent TCP connections
        being handled for any particular client. It is RECOMMENDED that for any 
        given client - server interaction there 
        SHOULD be no more than one connection for regular queries, one for zone 
        transfers and one for each protocol that is being used on top of TCP, 
        for example, if the resolver was using TLS.
        The server MUST NOT enforce these rules for a particular client because 
        it does not know if the client IP address belongs to a single client or 
        is, for example, multiple clients behind NAT.
      </t>
      
      <t>
        For reasons of efficiency, implementations SHOULD wherever possible 
        attempt to coalesce the two byte length field and subsequent DNS payload
        data into a single packet.
      </t>
      
      <t>
        If a server finds that a client has closed a TCP session, or if the
        session has been otherwise interrupted, before all pending responses
        have been sent then the server MUST NOT attempt to send those
        responses. Of course the server MAY cache those responses.
      </t>
      
    </section>
    <section title="Query Pipelining" anchor="pipelining">
      <t> Due to the use of TCP primarily for zone transfer and truncated
        responses, no existing RFC discusses the idea of pipelining DNS
        queries over a TCP connection.</t>

      <t> In order to achieve performance on par with UDP DNS clients SHOULD pipeline their queries.
        When a DNS client sends multiple queries to a server, it should
        not wait for an outstanding reply before sending the next query.
        Clients should treat TCP and UDP equivalently when considering
        the time at which to send a particular query.</t>

      <t> DNS servers (especially recursive) SHOULD expect to receive
        pipelined queries.  The server should process TCP queries in
        parallel, just as it would for UDP.  The handling of responses
        to pipelined queries is covered in the following section.</t>

      <t> When pipelining queries over TCP it is very easy to send more DNS
        queries than there are DNS Message ID's. Implementations MUST
        take care to check their list of outstanding DNS Message ID's
        before sending a new query over an existing TCP connection. This
        is especially important if the server could be performing
        out-of-order processing. In addition, when sending multiple queries over TCP it is very easy
        for a name server to overwhelm its own network interface.
        Implementations MUST take care to manage buffer sizes or to
        throttle writes to the network interface.</t>
       
    </section>


    

    <section title="Response Reordering" anchor="re-ordering">

      <t> RFC 1035 is ambiguous on the question of whether TCP responses may be reordered -- the
        only relevant text is in Section 4.2.1, which relates to UDP:<list>
          <t>
            <vspace/> Queries or their responses may be reordered by the network, or by
            processing in name servers, so resolvers should not depend on them being
            returned in order.</t>
        </list>
      </t>

      <t>
        For the avoidance of future doubt, this requirement is clarified. 
        Authoritative servers and recursive resolvers are RECOMMENDED to support the sending of responses in
        parallel and/or out-of-order, regardless of the transport protocol in use.
        Stub and recursive resolvers MUST be able to process responses 
        that arrive in a different order to that in which the requests were 
        sent, regardless of the transport protocol in use.
      </t>
      <t>
        In order to achieve performance on par with UDP, recursive
        resolvers SHOULD process TCP queries in parallel and return
        individual responses as soon as they are available, possibly
        out-of-order.
      </t>

      <t>
        Since responses may arrive out-of-order, clients must take
        care to match responses to outstanding queries, using the ID
        field, port number, query name/type/class, and any other relevant
        protocol features.
      </t>      

    </section>
    <section title="TCP Fast Open" anchor="fastopen">
      <t>
        This section is non-normative.
      </t>
      <t>
        TCP fastopen <xref target="RFC7413"></xref> (TFO) allows data
        to be carried in the SYN packet. It also saves up to one RTT compared to
        standard TCP.
      </t>
      <t>
        TFO mitigates the security vulnerabilities inherent in
        sending data in the SYN, especially on a system like DNS where
        amplification attacks are possible, by use of a server-supplied
        cookie.  TFO clients request a server cookie in the initial SYN
        packet at the start of a new connection.  The server returns a
        cookie in its SYN-ACK. The client caches the cookie and reuses
        it when opening subsequent connections to the same server.
      </t>
      <t>
        The cookie is stored by the client's TCP stack (kernel) and persists
        if either the client or server processes are restarted.  TFO also
        falls back to a regular TCP handshake gracefully.
      </t>
      <t>
        Adding support for this to existing name server implementations is relatively 
        easy, but	does require source code modifications.
        On the client, the call to connect() is replaced with a TFO aware version of
        sendmsg() or sendto(). On the server, TFO must be switched into server mode
        by changing the kernel parameter (net.ipv4.tcp_fastopen on Linux) to enable
        the server bit (Set the integer value to 2 (server only) or 3 (client and server)) and 
        setting a socket option between the bind() and listen() calls. 
      </t>
      <t> DNS services taking advantage of IP anycast <xref target="RFC4786"/>
        may need to take additional steps when enabling TFO.	From <xref
          target="RFC7413">
        </xref>: <list>
          <t>
            <vspace/>Servers that accept connection requests to
            the same server IP address should use the same key such that they
            generate identical Fast Open Cookies for a particular client IP
            address. Otherwise a client may get different cookies across
            connections; its Fast Open attempts would fall back to regular 3WHS.
          </t>
        </list>
      </t>
    </section>

        
        
    <section anchor="IANA" title="IANA Considerations">
      <t>This memo includes no request to IANA.</t>
    </section>
    <section title="Security Considerations" anchor="security">

      <t> Some DNS server operators have expressed concern that wider use of DNS over TCP will
        expose them to a higher risk of denial-of-service (DoS) attacks.</t>

      <t> Although there is a higher risk of such attacks against TCP-enabled servers,
        techniques for the mitigation of DoS attacks at the network level have improved
        substantially since DNS was first designed.</t>

      <t> Readers are advised to familiarise themselves with <xref
          target="CPNI-TCP"/>. </t>

      <t> Operators of recursive servers should ensure that they only accept connections from
        expected clients, and do not accept them from unknown sources. In the case of UDP
        traffic, this will help protect against <xref target="RFC5358">reflector
          attacks</xref> and in the case of TCP traffic it will prevent an unknown client from
        exhausting the server's limits on the number of concurrent connections.</t>

    </section>
    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>
        The authors would like to thank Francis Dupont for his detailed review,
        Liang Zhu, Zi Hu, and John
        Heidemann for extensive DNS-over-TCP discussions and code
        and Lucie Guiraud and Danny McPherson for reviewing early versions
        of this document. We would also like to thank all those who contributed
        to RFC 5966.
      </t>
    </section>


  </middle>
  <back>
    <references title="Normative References">
    &RFC2119;
    &RFC5966;
    &RFC5625;
    &RFC0793;
    &RFC0768;
    &RFC1123;
    &RFC1034;
    &RFC6891;
    &RFC4033;
    &RFC5155;
    &RFC1035;
    &RFC5358;
    &RFC4786;
    &RFC7230;
    </references>
    <references title="Informative References">
      &RFC7413;
      &RFC6824;
      <reference anchor="CPNI-TCP"
                 target="http://www.cpni.gov.uk/Docs/tn-03-09-security-assessment-TCP.pdf">
        <front>
          <title>Security Assessment of the Transmission Control Protocol (TCP)</title>
          <author>
            <organization>CPNI</organization>
          </author>
          <date year="2009"/>
        </front>
      </reference>
      <reference anchor="fragmentation-considered-poisonous" target="http://arxiv.org/abs/1205.4011">
        <front>
          <title>Fragmentation Considered Poisonous</title>
          <author initials="A." surname="Herzberg" fullname="Amir Herzberg">
            <organization>Dept. of Computer Science, Bar Ilan University</organization>
          </author>
          <author initials="H." surname="Shulman" fullname="Haya Shulman">
            <organization>Dept. of Computer Science, Bar Ilan University</organization>
          </author>
          <date month="May" year="2012"/>
        </front>
      </reference>
      <reference anchor="Connection-Oriented-DNS"
                 target="http://www.isi.edu/publications/trpublic/files/tr-693.pdf">
        <front>
          <title>T-DNS: Connection-Oriented DNS to Improve Privacy and Security (extended)</title>
          <author initials="L." surname="Zhu" fullname="Liang Zhu">
            <organization>University of Southern California</organization>
          </author>
          <author initials="Z." surname="Hu" fullname="Zi Hu">
            <organization>University of Southern California</organization>
          </author>
          <author initials="J." surname="Heidemann" fullname="Heidemann">
            <organization>University of Southern California</organization>
          </author>
          <author fullname="Duane Wessels" initials="D." surname="Wessels">
            <organization>Verisign Labs</organization>
          </author>
          <author fullname="Allison Mankin" initials="A." surname="Mankin">
            <organization>Verisign Labs</organization>
          </author>
          <author initials="N." surname="Somaiya" fullname="Nikita Somaiya">
            <organization>University of Southern California</organization>
          </author>
          <date/>
        </front>
      </reference>
    </references>
    <section title="Summary of Advantages and Disadvantages to using TCP for DNS">
      <t>
        The TCP handshake generally prevents address spoofing and, therefore, the
        reflection/amplification attacks which plague UDP.
      </t>
      <t>
        TCP does not suffer from UDP's issues with fragmentation.
        Middleboxes are known to block IP fragments, leading to
        timeouts and forcing client implementations to "hunt"
        for EDNS0 reply size values supported by the network path.
        Additionally, fragmentation may lead to cache poisoning <xref
          target="fragmentation-considered-poisonous"/>.
      </t>

      <t> TCP setup costs an additional RTT compared to UDP queries.
        Setup costs can be amortized by reusing connections, pipelining
        queries, and enabling TCP Fast Open.</t>

      <t> TCP imposes additional state-keeping requirements on clients
        and servers.  The use of TCP Fast Open reduces the cost of
        closing and re-opening TCP connections.</t>

      <t> Long-lived TCP connections to anycast servers may be disrupted
        due to routing changes.  Clients utilizing TCP for DNS must always
        be prepared to re-establish connections or otherwise retry outstanding
        queries. It may also possible for TCP Multipath <xref target="RFC6824"/>
        to allow a server to hand a 
        connection over from the anycast address to a unicast address.
      </t>

      <t> There are many "Middleboxes" in use today that interfere with
        TCP over port 53 <xref target="RFC5625"/>.  This document does
        not propose any solutions, other than to make it absolutely clear
        that TCP is a valid transport for DNS and must be supported by
        all implementations.</t>
        
    </section>
    <section title="Changes -00 to -01">
      <t>
        <list style="symbols">	
          <t>
            Changed updates to obsoletes RFC 5966.
          </t>
          <t>
            Improved text in Section 4 Transport Protocol Selection to change 
            "TCP SHOULD NOT be used only for the transfers and as a fallback" 
            to make the intention clearer and more consistent.
          </t>
          <t>
            Reference to TCP FASTOPEN updated now that it is an RFC.
          </t>
          <t>
            Added paragraph to say that implementations MUST NOT send the 
            TCP framing 2 byte length field in a separate packet to the DNS 
            message.
          </t>
          <t>
            Added Terminology section.
          </t>
          <t>
            Changed should and RECOMMENDED in reference to parallel processing
            to SHOULD in sections 7 and 8.
          </t>
          <t>
            Added text to address what a server should do when a client closes
            the TCP connection before pending responses are sent.
          </t>
          <t>
            Moved the Advantages and Disadvantages section to an appendix.
          </t> 
        </list>
      </t>
    </section>
    
    <section title="Changes to RFC 5966">
      <t>
        This document differs from RFC 5966 in four additions:<list style="numbers">
          <t>
            DNS implementations are recommended not only to support TCP but to support it on an equal footing with UDP
          </t>
          <t>
            DNS implementations are recommended to support reuse of TCP connections
          </t>
          <t>
            DNS implementations are recommended to support pipelining and out of order processing of the query stream
          </t>
          <t>
            A non-normative discussion of use of TCP Fast Open is added
          </t>
        </list>
      </t>
    </section>
  </back>
</rfc>
